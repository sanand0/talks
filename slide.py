#!uv run
#
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "markdown2",
#     "rich",
# ]
# ///
"""
Usage:
  uv run slide.py script.md         # Resets state and renders the first slide from script.md
  uv run slide.py                   # Next slide
  uv run slide.py +n or -n          # nth slide after/before current
  uv run slide.py N                 # nth slide
  uv run slide.py .                 # Current slide (+0)
  uv run slide.py ..                # Previous slide (-1)
  uv run slide.py :n                # nth slide from last
"""

import json
import markdown2
import os
import re
import sys
from html import unescape
from rich.console import Console

STATE_FILE = ".slide_state.json"


def get_sections(text):
    """
    Splits the markdown text into sections. A section is any block that begins
    with a heading (a line starting with '#' up to '######') that is not inside a code fence.
    """
    sections = []
    current = []
    in_code_block = False
    # Recognize both ``` and ~~~ as code fences.
    code_fence_pattern = re.compile(r"^\s*(```|~~~)")
    heading_pattern = re.compile(r"^(#{1,6})\s+")

    for line in text.splitlines():
        if code_fence_pattern.match(line):
            in_code_block = not in_code_block
        # Only consider a heading if not inside a code block.
        if not in_code_block and heading_pattern.match(line):
            if current:
                sections.append("\n".join(current))
            current = [line]
        else:
            current.append(line)
    if current:
        sections.append("\n".join(current))
    return sections


def load_state():
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return None


def save_state(state):
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(state, f)


def html_to_rich(html):
    """
    Converts a subset of HTML (as generated by markdown2) to Rich markup.
    This covers headings, bold, italics, inline and fenced code blocks, and links.
    """
    # Convert fenced code blocks first (<pre><code>...</code></pre>)
    html = re.sub(
        r"<pre><code>(.*?)</code></pre>",
        lambda m: f"[bold white]{m.group(1).strip()}[/bold white]",
        html,
        flags=re.DOTALL,
    )
    # Headings with left alignment (just by not adding any alignment tag)
    html = re.sub(
        r"<h1>(.*?)</h1>",
        lambda m: f"[bold underline cyan]{m.group(1).strip()}[/bold underline cyan]",
        html,
        flags=re.DOTALL,
    )
    html = re.sub(
        r"<h2>(.*?)</h2>",
        lambda m: f"[bold cyan]{m.group(1).strip()}[/bold cyan]",
        html,
        flags=re.DOTALL,
    )
    html = re.sub(
        r"<h3>(.*?)</h3>",
        lambda m: f"[bold yellow]{m.group(1).strip()}[/bold yellow]",
        html,
        flags=re.DOTALL,
    )
    # h4-h6: simply bolded.
    html = re.sub(
        r"<h[4-6]>(.*?)</h[4-6]>",
        lambda m: f"[bold]{m.group(1).strip()}[/bold]\n",
        html,
        flags=re.DOTALL,
    )
    # Blockquotes: render content in italics
    html = re.sub(
        r"<blockquote>(.*?)</blockquote>",
        lambda m: f"  [italic]{m.group(1).strip()}[/italic]",
        html,
        flags=re.DOTALL,
    )
    # Bold and italics.
    html = re.sub(
        r"<strong>(.*?)</strong>",
        lambda m: f"[bold yellow]{m.group(1).strip()}[/bold yellow]",
        html,
        flags=re.DOTALL,
    )
    html = re.sub(
        r"<em>(.*?)</em>",
        lambda m: f"[italic]{m.group(1).strip()}[/italic]",
        html,
        flags=re.DOTALL,
    )
    # Inline code.
    html = re.sub(
        r"<code>(.*?)</code>",
        lambda m: f"[bold white]{m.group(1).strip()}[/bold white]",
        html,
        flags=re.DOTALL,
    )
    # Links (ignore URL, color the link text)
    html = re.sub(
        r'<a href="[^"]*">(.*?)</a>',
        lambda m: f"[underline cyan]{m.group(1).strip()}[/underline cyan]",
        html,
        flags=re.DOTALL,
    )

    # Lists: render <ul>/<ol> with indicators before stripping tags.
    def _render_ul(match: re.Match) -> str:
        """Render unordered list items as '- item' lines."""
        inner = match.group(1)
        items = re.findall(r"<li>(.*?)</li>", inner, flags=re.DOTALL)
        lines = [f"- {unescape(i).strip()}" for i in items]
        return "\n".join(lines)

    def _render_ol(match: re.Match) -> str:
        """Render ordered list items as 'n. item' lines starting at 1."""
        inner = match.group(1)
        items = re.findall(r"<li>(.*?)</li>", inner, flags=re.DOTALL)
        lines = [f"{idx}. {unescape(i).strip()}" for idx, i in enumerate(items, start=1)]
        return "\n".join(lines)

    # Replace nested lists iteratively (inner-most first).
    prev_html = None
    while prev_html != html:
        prev_html = html
        html = re.sub(r"<ol>(.*?)</ol>", _render_ol, html, flags=re.DOTALL)
        html = re.sub(r"<ul>(.*?)</ul>", _render_ul, html, flags=re.DOTALL)

    # Remove paragraph tags.
    html = re.sub(r"</?p>", "", html, flags=re.DOTALL)
    # Remove any remaining stray HTML tags.
    html = re.sub(r"<[^>]+>", "", html)
    # Unescape HTML entities
    html = unescape(html.replace("&nsbp;", " "))
    # Replace 3+ newlines with a 2 newlines
    return re.sub(r"\n\n\n+", "\n\n", html).strip()


def clear_screen():
    os.system("cls" if os.name == "nt" else "clear")


def main():
    # Parse command-line arguments.
    filename = None
    flag, nslides = "next", 1
    arg = sys.argv[1] if len(sys.argv) > 1 else ""
    # nslides captures the last digits in args if any
    matches = re.search(r"[+-]?\d+$", arg)
    if matches:
        nslides = int(matches.group(0))
    if arg == "..":
        flag, nslides = "next", -1
    elif arg == ".":
        flag, nslides = "next", 0
    elif arg.startswith(("+", "-")):
        flag = "next"
    elif arg.startswith((":")):
        flag = "last"
    elif arg.isdigit():
        flag = "set"
    else:
        filename = arg

    # If a filename is provided, reset state.
    if filename:
        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            sys.exit(1)
        with open(filename, "r", encoding="utf-8") as f:
            content = f.read()
        sections = get_sections(content)
        if not sections:
            print("No sections found in the file.")
            sys.exit(0)
        # Reset state with the first slide.
        state = {"filename": filename, "current_slide": 0, "total": len(sections)}
        slide_index = 0
        save_state(state)
    else:
        state = load_state()
        if not state:
            print("No state found. Please run with a markdown file first.")
            sys.exit(1)
        filename = state["filename"]
        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            sys.exit(1)
        with open(filename, "r", encoding="utf-8") as f:
            content = f.read()
        sections = get_sections(content)
        total = len(sections)
        current = state["current_slide"]

        if flag == "set":
            slide_index = nslides
        elif flag == "last":
            slide_index = total - nslides
        elif flag == "next":
            slide_index = current + nslides
            if slide_index < 0:
                slide_index = 0
                print("Already at first slide.")
                sys.exit(-1)
            if slide_index >= total:
                slide_index = total - 1
                print("Already at last slide.")
                sys.exit(-1)
        state["current_slide"] = slide_index
        state["total"] = total
        save_state(state)

    # Clear screen before printing the slide.
    clear_screen()

    # Convert markdown to HTML (with fenced-code-blocks extra) then to Rich markup.
    html = markdown2.markdown(sections[slide_index], extras=["fenced-code-blocks"])
    rich_markup = html_to_rich(html)

    # Print using Rich console, stripping trailing spaces for easier copy-pasting
    console = Console()
    with console.capture() as cap:
        console.print(rich_markup + "\n", markup=True, justify="left")
    out = cap.get()
    for line in out.splitlines():
        print(line.rstrip())

if __name__ == "__main__":
    main()
